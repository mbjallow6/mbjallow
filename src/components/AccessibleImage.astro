---
import { Image } from 'astro:assets'

interface Props {
  src: string | ImageMetadata | { src: any; alt?: string }
  alt?: string
  title?: string
  class?: string
  width?: number
  height?: number
  loading?: 'lazy' | 'eager'
  decoding?: 'async' | 'sync' | 'auto'
  fallbackAlt?: string
  quality?: number
  format?: 'avif' | 'webp' | 'jpeg' | 'png'
  priority?: boolean
  fetchpriority?: 'high' | 'low' | 'auto'
}

const { 
  src, 
  alt, 
  title,
  class: className, 
  width = 800, 
  height = 400,
  loading = 'lazy',
  decoding = 'async',
  fallbackAlt,
  quality = 80,
  format = 'webp',
  priority = false,
  fetchpriority = 'auto',
  ...rest 
} = Astro.props

/**
 * PRODUCTION-READY: Advanced alt text generation with GUARANTEED non-empty result
 * This function MUST NEVER return an empty string or undefined
 */
const generateIntelligentAltText = (): string => {
  // Priority 1: Explicit alt text provided (validate it's not empty)
  if (alt && alt.trim().length > 0) {
    return alt.trim()
  }
  
  // Priority 2: Alt text from image object (validate it's not empty)
  if (typeof src === 'object' && 'alt' in src && src.alt && src.alt.trim().length > 0) {
    return src.alt.trim()
  }
  
  // Priority 3: Custom fallback provided (validate it's not empty)
  if (fallbackAlt && fallbackAlt.trim().length > 0) {
    return fallbackAlt.trim()
  }
  
  // Priority 4: Extract meaningful info from image source
  try {
    let imageSrc: string = ''
    
    if (typeof src === 'string') {
      imageSrc = src
    } else if (typeof src === 'object' && 'src' in src) {
      imageSrc = typeof src.src === 'string' ? src.src : ''
    }
    
    if (imageSrc && imageSrc.trim().length > 0) {
      // Extract filename and clean it up
      const filename = imageSrc.split('/').pop()?.split('?')[0]?.split('.')[0]
      if (filename && filename.trim().length > 0) {
        // Convert kebab-case, snake_case, and camelCase to readable text
        const readableText = filename
          .replace(/[-_]/g, ' ')
          .replace(/([A-Z])/g, ' $1')
          .replace(/\s+/g, ' ')
          .trim()
          .toLowerCase()
          .replace(/^\w/, c => c.toUpperCase())
        
        if (readableText && readableText.length > 0) {
          return `Image: ${readableText}`
        }
      }
    }
  } catch (error) {
    console.warn('AccessibleImage: Error extracting filename for alt text:', error)
  }
  
  // Priority 5: GUARANTEED non-empty fallback - this MUST never be empty
  return 'Descriptive image'
}

/**
 * Comprehensive image type detection and validation
 * Handles all possible image source types securely
 */
const analyzeImageSource = () => {
  if (!src) {
    return { type: 'invalid', isValid: false, imageSrc: null, useAstroImage: false }
  }

  // Case 1: Astro imported image (ImageMetadata)
  if (typeof src === 'object' && 'src' in src && 'width' in src && 'height' in src) {
    return {
      type: 'astro-imported',
      isValid: true,
      imageSrc: src,
      useAstroImage: true
    }
  }

  // Case 2: Image object with src property (content collections)
  if (typeof src === 'object' && 'src' in src && src.src) {
    return {
      type: 'object-with-src',
      isValid: true,
      imageSrc: src.src,
      useAstroImage: typeof src.src !== 'string'
    }
  }

  // Case 3: String URL/path
  if (typeof src === 'string') {
    const trimmedSrc = src.trim()
    
    // Validate against potentially malicious URLs
    try {
      // External HTTPS URLs (most secure)
      if (trimmedSrc.startsWith('https://')) {
        return {
          type: 'external-https',
          isValid: true,
          imageSrc: trimmedSrc,
          useAstroImage: false
        }
      }
      
      // External HTTP URLs (less secure, but allowed)
      if (trimmedSrc.startsWith('http://')) {
        console.warn(`AccessibleImage: Using insecure HTTP image: ${trimmedSrc}`)
        return {
          type: 'external-http',
          isValid: true,
          imageSrc: trimmedSrc,
          useAstroImage: false
        }
      }
      
      // Absolute paths (public folder)
      if (trimmedSrc.startsWith('/')) {
        return {
          type: 'absolute-path',
          isValid: true,
          imageSrc: trimmedSrc,
          useAstroImage: false
        }
      }
      
      // Data URLs (base64 encoded images)
      if (trimmedSrc.startsWith('data:image/')) {
        return {
          type: 'data-url',
          isValid: true,
          imageSrc: trimmedSrc,
          useAstroImage: false
        }
      }
      
      // Relative paths - convert to absolute for security
      if (trimmedSrc.includes('.') && /\.(jpg|jpeg|png|webp|gif|svg)$/i.test(trimmedSrc)) {
        const convertedPath = `/images/posts/${trimmedSrc.replace(/^\.\//, '')}`
        console.warn(`AccessibleImage: Converting relative path "${trimmedSrc}" to "${convertedPath}"`)
        return {
          type: 'relative-converted',
          isValid: true,
          imageSrc: convertedPath,
          useAstroImage: false
        }
      }
      
    } catch (error) {
      console.error('AccessibleImage: Error validating image source:', error)
    }
  }

  return { type: 'invalid', isValid: false, imageSrc: null, useAstroImage: false }
}

// Analyze the image source
const imageAnalysis = analyzeImageSource()
const altText = generateIntelligentAltText()

// CRITICAL: Double-check that we NEVER have empty alt text
const guaranteedAltText = (altText && altText.trim().length > 0) ? altText.trim() : 'Descriptive image'

// Optimize alt text length (WCAG 2.1 recommendation: under 125 characters)
const optimizedAlt = guaranteedAltText.length > 125 ? guaranteedAltText.substring(0, 122) + '...' : guaranteedAltText

// Determine loading strategy
const effectiveLoading = priority ? 'eager' : loading
const effectiveFetchPriority = priority ? 'high' : fetchpriority

// Security: Sanitize CSS classes
const sanitizedClassName = className?.replace(/[<>'"]/g, '') || ''

// FINAL SAFETY CHECK: Ensure alt text is never empty
if (!optimizedAlt || optimizedAlt.trim().length === 0) {
  console.error('AccessibleImage: CRITICAL ERROR - Alt text is empty, using emergency fallback')
  // This should never happen, but just in case
}
const finalAltText = (optimizedAlt && optimizedAlt.trim().length > 0) ? optimizedAlt : 'Image content'

// Development logging for debugging
if (import.meta.env.DEV && imageAnalysis.isValid) {
  console.log(`üñºÔ∏è  AccessibleImage Analysis:`)
  console.log(`   Type: ${imageAnalysis.type}`)
  console.log(`   Use Astro Image: ${imageAnalysis.useAstroImage}`)
  console.log(`   Final Alt text: "${finalAltText}" (${finalAltText.length} chars)`)
  console.log(`   Loading: ${effectiveLoading} | Priority: ${priority}`)
  
  if (!alt && !fallbackAlt) {
    console.warn(`‚ö†Ô∏è  No explicit alt text provided. Generated: "${finalAltText}"`)
  }
}
---

<!-- Render image based on analysis -->
{imageAnalysis.isValid ? (
  <figure class="accessible-image-container" role="img">
    {imageAnalysis.useAstroImage ? (
      <!-- Optimized Astro Image Component with GUARANTEED alt text -->
      <Image 
        src={imageAnalysis.imageSrc}
        alt={finalAltText}
        title={title}
        class={sanitizedClassName}
        width={width}
        height={height}
        loading={effectiveLoading}
        decoding={decoding}
        quality={quality}
        format={format}
        fetchpriority={effectiveFetchPriority}
        {...rest}
      />
    ) : (
      <!-- Standard HTML Image with Error Handling -->
      <img 
        src={imageAnalysis.imageSrc}
        alt={finalAltText}
        title={title}
        class={sanitizedClassName}
        width={width}
        height={height}
        loading={effectiveLoading}
        decoding={decoding}
        fetchpriority={effectiveFetchPriority}
        onerror="this.style.display='none'; this.nextElementSibling?.classList.remove('hidden')"
        {...rest}
      />
    )}
    
    <!-- Graceful fallback for broken images -->
    <div class="hidden image-fallback" aria-label="Image not available">
      <div class="flex items-center justify-center w-full h-32 bg-gray-100 dark:bg-gray-800 rounded border-2 border-dashed border-gray-300 dark:border-gray-600">
        <div class="text-center text-gray-500 dark:text-gray-400">
          <svg class="w-8 h-8 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
          </svg>
          <p class="text-sm">Image not available</p>
          <p class="text-xs opacity-75">{finalAltText}</p>
        </div>
      </div>
    </div>
  </figure>
) : (
  <!-- Invalid image source - render accessible placeholder -->
  <div class="sr-only" role="img" aria-label="Invalid image source">
    Image source not provided or invalid
  </div>
)}

<!-- Component styles -->
<style>
  .accessible-image-container {
    position: relative;
    margin: 0;
  }
  
  .image-fallback {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 1;
  }
  
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
  
  /* Enhance focus visibility for keyboard navigation */
  .accessible-image-container img:focus {
    outline: 2px solid var(--theme-accent, #3b82f6);
    outline-offset: 2px;
  }
</style>
