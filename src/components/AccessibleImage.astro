---
import { Image } from 'astro:assets'

interface Props {
  src: string | ImageMetadata | { src: any; alt?: string }
  alt?: string
  title?: string
  class?: string
  width?: number
  height?: number
  loading?: 'lazy' | 'eager'
  decoding?: 'async' | 'sync' | 'auto'
  fallbackAlt?: string
  quality?: number
  format?: 'avif' | 'webp' | 'jpeg' | 'png'
  priority?: boolean
  fetchpriority?: 'high' | 'low' | 'auto'
}

const { 
  src, 
  alt, 
  title,
  class: className, 
  width = 800, 
  height = 400,
  loading = 'lazy',
  decoding = 'async',
  fallbackAlt,
  quality = 80,
  format = 'webp',
  priority = false,
  fetchpriority = 'auto',
  ...rest 
} = Astro.props

/**
 * Advanced alt text generation with intelligent fallbacks
 * Follows WCAG 2.1 AA guidelines and semantic best practices
 */
const generateIntelligentAltText = (): string => {
  // Priority 1: Explicit alt text provided
  if (alt && alt.trim().length > 0) {
    return alt.trim()
  }
  
  // Priority 2: Alt text from image object (imported images)
  if (typeof src === 'object' && 'alt' in src && src.alt) {
    return src.alt
  }
  
  // Priority 3: Custom fallback provided
  if (fallbackAlt && fallbackAlt.trim().length > 0) {
    return fallbackAlt.trim()
  }
  
  // Priority 4: Extract meaningful info from image source
  try {
    let imageSrc: string = ''
    
    if (typeof src === 'string') {
      imageSrc = src
    } else if (typeof src === 'object' && 'src' in src) {
      imageSrc = typeof src.src === 'string' ? src.src : ''
    }
    
    if (imageSrc) {
      // Extract filename and clean it up
      const filename = imageSrc.split('/').pop()?.split('?')[0]?.split('.')[0]
      if (filename) {
        // Convert kebab-case, snake_case, and camelCase to readable text
        const readableText = filename
          .replace(/[-_]/g, ' ')
          .replace(/([A-Z])/g, ' $1')
          .replace(/\s+/g, ' ')
          .trim()
          .toLowerCase()
          .replace(/^\w/, c => c.toUpperCase())
        
        return readableText ? `Image: ${readableText}` : 'Image'
      }
    }
  } catch (error) {
    console.warn('AccessibleImage: Error extracting filename for alt text:', error)
  }
  
  // Priority 5: Generic but meaningful fallback
  return 'Image'
}

/**
 * Comprehensive image type detection and validation
 * Handles all possible image source types securely
 */
const analyzeImageSource = () => {
  if (!src) {
    return { type: 'invalid', isValid: false, imageSrc: null, useAstroImage: false }
  }

  // Case 1: Astro imported image (ImageMetadata)
  if (typeof src === 'object' && 'src' in src && 'width' in src && 'height' in src) {
    return {
      type: 'astro-imported',
      isValid: true,
      imageSrc: src,
      useAstroImage: true
    }
  }

  // Case 2: Image object with src property (content collections)
  if (typeof src === 'object' && 'src' in src && src.src) {
    return {
      type: 'object-with-src',
      isValid: true,
      imageSrc: src.src,
      useAstroImage: typeof src.src !== 'string'
    }
  }

  // Case 3: String URL/path
  if (typeof src === 'string') {
    const trimmedSrc = src.trim()
    
    // Validate against potentially malicious URLs
    try {
      // External HTTPS URLs (most secure)
      if (trimmedSrc.startsWith('https://')) {
        return {
          type: 'external-https',
          isValid: true,
          imageSrc: trimmedSrc,
          useAstroImage: false
        }
      }
      
      // External HTTP URLs (less secure, but allowed)
      if (trimmedSrc.startsWith('http://')) {
        console.warn(`AccessibleImage: Using insecure HTTP image: ${trimmedSrc}`)
        return {
          type: 'external-http',
          isValid: true,
          imageSrc: trimmedSrc,
          useAstroImage: false
        }
      }
      
      // Absolute paths (public folder)
      if (trimmedSrc.startsWith('/')) {
        return {
          type: 'absolute-path',
          isValid: true,
          imageSrc: trimmedSrc,
          useAstroImage: false
        }
      }
      
      // Data URLs (base64 encoded images)
      if (trimmedSrc.startsWith('data:image/')) {
        return {
          type: 'data-url',
          isValid: true,
          imageSrc: trimmedSrc,
          useAstroImage: false
        }
      }
      
      // Relative paths - convert to absolute for security
      if (trimmedSrc.includes('.') && (trimmedSrc.includes('jpg') || trimmedSrc.includes('png') || trimmedSrc.includes('webp') || trimmedSrc.includes('gif'))) {
        const convertedPath = `/images/posts/${trimmedSrc.replace(/^\.\//, '')}`
        console.warn(`AccessibleImage: Converting relative path "${trimmedSrc}" to "${convertedPath}"`)
        return {
          type: 'relative-converted',
          isValid: true,
          imageSrc: convertedPath,
          useAstroImage: false
        }
      }
      
    } catch (error) {
      console.error('AccessibleImage: Error validating image source:', error)
    }
  }

  return { type: 'invalid', isValid: false, imageSrc: null, useAstroImage: false }
}

// Analyze the image source
const imageAnalysis = analyzeImageSource()
const altText = generateIntelligentAltText()

// Optimize alt text length (WCAG 2.1 recommendation: under 125 characters)
const optimizedAlt = altText.length > 125 ? altText.substring(0, 122) + '...' : altText

// Determine loading strategy
const effectiveLoading = priority ? 'eager' : loading
const effectiveFetchPriority = priority ? 'high' : fetchpriority

// Security: Sanitize CSS classes
const sanitizedClassName = className?.replace(/[<>'"]/g, '') || ''

// Development logging for debugging
if (import.meta.env.DEV && imageAnalysis.isValid) {
  console.log(`üñºÔ∏è  AccessibleImage Analysis:`)
  console.log(`   Type: ${imageAnalysis.type}`)
  console.log(`   Use Astro Image: ${imageAnalysis.useAstroImage}`)
  console.log(`   Alt text: "${optimizedAlt}" (${optimizedAlt.length} chars)`)
  console.log(`   Loading: ${effectiveLoading} | Priority: ${priority}`)
  
  if (!alt && !fallbackAlt) {
    console.warn(`‚ö†Ô∏è  No explicit alt text provided. Generated: "${optimizedAlt}"`)
  }
}
---

<!-- Render image based on analysis -->
{imageAnalysis.isValid ? (
  <figure class="accessible-image-container" role="img">
    {imageAnalysis.useAstroImage ? (
      <!-- Optimized Astro Image Component -->
      <Image 
        src={imageAnalysis.imageSrc}
        alt={optimizedAlt}
        title={title}
        class={sanitizedClassName}
        width={width}
        height={height}
        loading={effectiveLoading}
        decoding={decoding}
        quality={quality}
        format={format}
        fetchpriority={effectiveFetchPriority}
        {...rest}
      />
    ) : (
      <!-- Standard HTML Image with Error Handling -->
      <img 
        src={imageAnalysis.imageSrc}
        alt={optimizedAlt}
        title={title}
        class={sanitizedClassName}
        width={width}
        height={height}
        loading={effectiveLoading}
        decoding={decoding}
        fetchpriority={effectiveFetchPriority}
        onerror="this.style.display='none'; this.nextElementSibling?.classList.remove('hidden')"
        {...rest}
      />
    )}
    
    <!-- Graceful fallback for broken images -->
    <div class="hidden image-fallback" aria-label="Image not available">
      <div class="flex items-center justify-center w-full h-32 bg-gray-100 dark:bg-gray-800 rounded border-2 border-dashed border-gray-300 dark:border-gray-600">
        <div class="text-center text-gray-500 dark:text-gray-400">
          <svg class="w-8 h-8 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
          </svg>
          <p class="text-sm">Image not available</p>
          <p class="text-xs opacity-75">{optimizedAlt}</p>
        </div>
      </div>
    </div>
  </figure>
) : (
  <!-- Invalid image source - render accessible placeholder -->
  <div class="sr-only" role="img" aria-label="Invalid image source">
    Image source not provided or invalid
  </div>
)}

<!-- Component styles -->
<style>
  .accessible-image-container {
    position: relative;
    margin: 0;
  }
  
  .image-fallback {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 1;
  }
  
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
  
  /* Enhance focus visibility for keyboard navigation */
  .accessible-image-container img:focus {
    outline: 2px solid var(--theme-accent, #3b82f6);
    outline-offset: 2px;
  }
</style>
