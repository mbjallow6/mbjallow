---
// file: src/components/AccessibleImage.astro
import { Image } from 'astro:assets'
import type { ImageMetadata } from 'astro'

interface Props {
  src: string | ImageMetadata | { src: any; alt?: string } | null | undefined
  alt?: string
  title?: string
  class?: string
  width?: number
  height?: number
  loading?: 'lazy' | 'eager'
  decoding?: 'async' | 'sync' | 'auto'
  fallbackAlt?: string
  quality?: number
  format?: 'avif' | 'webp' | 'jpeg' | 'png'
  priority?: boolean
  fetchpriority?: 'high' | 'low' | 'auto'
  inferSize?: boolean
}

const { 
  src, 
  alt, 
  title,
  class: className, 
  width = 800, 
  height = 400,
  loading = 'lazy',
  decoding = 'async',
  fallbackAlt,
  quality = 80,
  format = 'webp',
  priority = false,
  fetchpriority = 'auto',
  inferSize = true, // DEFAULT: Enable automatic dimension inference
  ...rest 
} = Astro.props

/**
 * BULLETPROOF: String processing for all path types
 */
const processStringSource = (stringSrc: string) => {
  let processed = stringSrc.trim()
  
  if (!processed || processed.length === 0) {
    return { isValid: false, finalSrc: null, reason: 'empty-string' }
  }

  try {
    // CRITICAL: Remove 'public/' prefix (common mistake)
    if (processed.startsWith('public/')) {
      processed = '/' + processed.substring(7)
      console.warn(`AccessibleImage: Fixed path - removed 'public/' prefix: "${stringSrc}" -> "${processed}"`)
    }

    // External HTTPS URLs
    if (processed.startsWith('https://')) {
      return { isValid: true, finalSrc: processed, reason: 'https-url' }
    }
    
    // External HTTP URLs (with warning)
    if (processed.startsWith('http://')) {
      console.warn(`AccessibleImage: Insecure HTTP URL: ${processed}`)
      return { isValid: true, finalSrc: processed, reason: 'http-url' }
    }
    
    // Public folder paths - PERFECT for Astro Image with inferSize
    if (processed.startsWith('/')) {
      return { isValid: true, finalSrc: processed, reason: 'public-path' }
    }
    
    // Data URLs
    if (processed.startsWith('data:image/')) {
      return { isValid: true, finalSrc: processed, reason: 'data-url' }
    }
    
    // Relative paths - convert to absolute
    if (processed.startsWith('./') || processed.startsWith('../')) {
      let converted = processed.replace(/^\.\.?\//, '')
      if (/\.(jpg|jpeg|png|webp|gif|svg|avif)$/i.test(converted)) {
        converted = `/images/${converted}`
        console.warn(`AccessibleImage: Converting relative path "${processed}" to "${converted}"`)
        return { isValid: true, finalSrc: converted, reason: 'converted-relative' }
      }
    }
    
    // Plain filename - assume public/images
    if (processed.includes('.') && /\.(jpg|jpeg|png|webp|gif|svg|avif)$/i.test(processed) && !processed.includes('/')) {
      const assumed = `/images/${processed}`
      console.warn(`AccessibleImage: Assuming "${processed}" is at "${assumed}"`)
      return { isValid: true, finalSrc: assumed, reason: 'assumed-location' }
    }
    
    // Invalid format
    return { isValid: false, finalSrc: null, reason: 'invalid-format' }
    
  } catch (error) {
    console.error('AccessibleImage: String processing error:', error)
    return { isValid: false, finalSrc: null, reason: 'processing-error' }
  }
}

/**
 * OPTIMAL: Image source validation that enables Astro Image for ALL valid sources
 */
const validateImageSource = () => {
  // Early exit for invalid sources
  if (!src || src === '' || src === null || src === undefined) {
    return { 
      isValid: false, 
      finalSrc: null, 
      reason: 'no-source',
      useInferSize: false
    }
  }

  try {
    // Case 1: ImageMetadata object (imported images) - No inferSize needed
    if (typeof src === 'object' && src !== null && 'src' in src && 'width' in src && 'height' in src) {
      return {
        isValid: true,
        finalSrc: src,
        reason: 'imported-image-metadata',
        useInferSize: false // Already has dimensions
      }
    }

    // Case 2: Object with nested ImageMetadata
    if (typeof src === 'object' && src !== null && 'src' in src) {
      if (typeof src.src === 'object' && src.src !== null && 'width' in src.src && 'height' in src.src) {
        return {
          isValid: true,
          finalSrc: src.src,
          reason: 'nested-image-metadata',
          useInferSize: false // Already has dimensions
        }
      }
      
      // If src is a string within object, process it
      if (typeof src.src === 'string') {
        const processedSrc = processStringSource(src.src)
        return {
          isValid: processedSrc.isValid,
          finalSrc: processedSrc.finalSrc,
          reason: `object-string-${processedSrc.reason}`,
          useInferSize: true // String sources need inferSize
        }
      }
    }

    // Case 3: String source - Use inferSize for optimization
    if (typeof src === 'string') {
      const processedSrc = processStringSource(src)
      return {
        isValid: processedSrc.isValid,
        finalSrc: processedSrc.finalSrc,
        reason: processedSrc.reason,
        useInferSize: true // String sources need inferSize
      }
    }

    // Invalid type
    return { 
      isValid: false, 
      finalSrc: null, 
      reason: 'invalid-type',
      useInferSize: false
    }

  } catch (error) {
    console.error('AccessibleImage: Critical validation error:', error)
    return { 
      isValid: false, 
      finalSrc: null, 
      reason: 'validation-error',
      useInferSize: false
    }
  }
}

/**
 * COMPREHENSIVE: Alt text generation
 */
const generateAltText = (): string => {
  // Priority 1: Explicit alt
  if (alt && typeof alt === 'string' && alt.trim().length > 0) {
    return alt.trim()
  }
  
  // Priority 2: Alt from src object
  if (typeof src === 'object' && src !== null && 'alt' in src && 
      src.alt && typeof src.alt === 'string' && src.alt.trim().length > 0) {
    return src.alt.trim()
  }
  
  // Priority 3: Fallback alt
  if (fallbackAlt && typeof fallbackAlt === 'string' && fallbackAlt.trim().length > 0) {
    return fallbackAlt.trim()
  }
  
  // Priority 4: Generate from filename
  try {
    const validation = validateImageSource()
    if (validation.isValid && validation.finalSrc) {
      let imagePath = ''
      
      if (typeof validation.finalSrc === 'string') {
        imagePath = validation.finalSrc
      } else if (typeof validation.finalSrc === 'object' && 'src' in validation.finalSrc) {
        imagePath = validation.finalSrc.src
      }
      
      if (imagePath) {
        const filename = imagePath.split('/').pop()?.split('?')[0]?.split('.')[0]
        if (filename && filename.length > 0) {
          const readable = filename
            .replace(/[-_]/g, ' ')
            .replace(/([A-Z])/g, ' $1')
            .replace(/\s+/g, ' ')
            .trim()
            .toLowerCase()
            .replace(/^\w/, c => c.toUpperCase())
          
          if (readable.length > 0) {
            return `Image: ${readable}`
          }
        }
      }
    }
  } catch (error) {
    console.warn('AccessibleImage: Alt generation error:', error)
  }
  
  // Final fallback - NEVER empty
  return 'Descriptive image'
}

// Execute validation and alt text generation
const validation = validateImageSource()
const altText = generateAltText()

// Ensure alt text is never empty and reasonable length
const finalAlt = altText.length > 125 ? altText.substring(0, 122) + '...' : altText
const guaranteedAlt = (finalAlt && finalAlt.trim().length > 0) ? finalAlt.trim() : 'Image content'

// Performance settings
const effectiveLoading = priority ? 'eager' : loading
const effectiveFetchPriority = priority ? 'high' : fetchpriority

// Determine if we should use inferSize
const shouldInferSize = validation.useInferSize && inferSize

// Security: Sanitize CSS
const sanitizedClassName = className ? className.replace(/[<>'"]/g, '').trim() : ''

// Development debugging
if (import.meta.env.DEV) {
  console.log(`üöÄ AccessibleImage Optimized Debug:`)
  console.log(`   Original Source:`, src)
  console.log(`   Validation:`, validation)
  console.log(`   Final Alt: "${guaranteedAlt}" (${guaranteedAlt.length} chars)`)
  console.log(`   Using inferSize: ${shouldInferSize}`)
  console.log(`   üéØ USING ASTRO IMAGE COMPONENT FOR OPTIMAL PERFORMANCE`)
  
  if (!validation.isValid) {
    console.error(`‚ùå INVALID IMAGE SOURCE - Reason: ${validation.reason}`)
  }
}
---

<!-- OPTIMAL: Always use Astro Image Component for maximum performance -->
{validation.isValid ? (
  <figure class="accessible-image-container" role="img" aria-label={guaranteedAlt}>
    <Image 
      src={validation.finalSrc}
      alt={guaranteedAlt}
      title={title || guaranteedAlt}
      class={sanitizedClassName}
      width={shouldInferSize ? undefined : width}
      height={shouldInferSize ? undefined : height}
      inferSize={shouldInferSize}
      loading={effectiveLoading}
      decoding={decoding}
      quality={quality}
      format={format}
      fetchpriority={effectiveFetchPriority}
      {...rest}
    />
    
    <!-- Error fallback -->
    <div class="hidden image-fallback" role="img" aria-label="Image not available">
      <div class="flex items-center justify-center w-full h-32 bg-gray-100 dark:bg-gray-800 rounded border-2 border-dashed border-gray-300 dark:border-gray-600">
        <div class="text-center text-gray-500 dark:text-gray-400">
          <svg class="w-8 h-8 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
          </svg>
          <p class="text-sm font-medium">Optimized image not available</p>
          <p class="text-xs opacity-75 mt-1">{guaranteedAlt}</p>
          {import.meta.env.DEV && (
            <p class="text-xs opacity-50 mt-1 font-mono">Reason: {validation.reason}</p>
          )}
        </div>
      </div>
    </div>
  </figure>
) : (
  <!-- Invalid source handling -->
  <div class="sr-only" role="img" aria-label={guaranteedAlt}>
    {import.meta.env.DEV ? (
      <div class="border-2 border-red-300 bg-red-50 dark:bg-red-900/20 p-4 rounded-lg">
        <div class="flex items-center gap-2">
          <svg class="w-5 h-5 text-red-600 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 15.5c-.77.833.192 2.5 1.732 2.5z"></path>
          </svg>
          <div>
            <p class="text-red-700 text-sm font-semibold">Invalid Image Source</p>
            <p class="text-red-600 text-xs">Reason: {validation.reason}</p>
            <p class="text-red-600 text-xs font-mono break-all">Source: {JSON.stringify(src)}</p>
          </div>
        </div>
      </div>
    ) : (
      <span>Image source not available</span>
    )}
  </div>
)}

<style>
  .accessible-image-container {
    position: relative;
    margin: 0;
    display: block;
  }
  
  .image-fallback {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 1;
  }
  
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
  
  .accessible-image-container img:focus,
  .accessible-image-container Image:focus {
    outline: 2px solid var(--theme-accent, #3b82f6);
    outline-offset: 2px;
    border-radius: 4px;
  }
  
  .accessible-image-container img,
  .accessible-image-container Image {
    max-width: 100%;
    height: auto;
  }
</style>
